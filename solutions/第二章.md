#### 第二章

2.1-1 A={31, 41, 59, 26, 41, 58}. 

​	第一步：31, 41, 59, 26, 41, 58

​	第二步：31, 41, 59, 26, 41, 58

​	第三步：26, 31, 41, 59, 41, 58

​	第四步：26, 31, 41, 41, 59, 58

​	第五步：26, 31, 41, 41, 58, 59

2.1-2

```c++
std::vector<int> & re_insertion_sort(std::vector<int> & s){
    int i = 0, key;
    for(int j = 1; j < s.size(); ++j){
        key = s[j];
        i = j - 1;
        while(i >= 0 && s[i] < key){
            s[i + 1] = s[i];
            i = i - 1;
        }
        s[i + 1] = key;
    }
    return s;
}
```

2.1-3

```c++
int linear_search(std::vector<int> & s, int v){
    int i = 0;
    while(i < s.size() && s[i++] != v){}
    return i == s.size() ? NIL : i-1;
}
```

2.1-4

```c++
std::vector<int> addition(std::vector<int> &A, std::vector<int> &B, int n){
    std::vector<int> C(n + 1, 0);
    int c = 0;
    for(int i = C.size() - 1; i >= 1; --i){
        C[i] = (c + A[i-1] + B[i-1]) % 2;
        c = (c + A[i-1] + B[i-1]) / 2;
    }
    C[0] = c;
    return C;
}
```

---

2.2-1 $n^3/1000-100n^2-100n+3=\Theta(n^3)$

2.2-2

```c++
std::vector<int> & selection_sort(std::vector<int> &s){
    int i = 0, j = 0, min = 0;
    for(i = 0; i < s.size() - 1; ++i){
        min = i;
        for(j = i + 1; j < s.size(); ++j){
            if(s[j] < s[min]) min = j;
        }
        std::swap(s[i], s[min]);
    }
    return s;
}
```

根据每一行列出运行时间:

$T(n)=c_1+c_2n+c_3(n-1)+c_4n+c_5\sum_{i=1}^nt_i+c_6(n-1)$

最好情况: 已经按顺序排好了，那么对于第五行，$t_i=c\sum_{j=i+1}^n$，可知，是$\Theta(n^2)$

最坏情况: 完全倒序，那么对于第五行$t_i=c\sum_{j=i+1}^n+c'\sum_{j=i+1}^n$，也是$\Theta(n^2)$

2.2-3

假设要查找的元素位置为$j\in\{1, 2, 3,...,n\}$，且概率为$P=\frac{1}{n}$，那么平均需要检查的次数为$E[j]=\frac{1}{n}\sum_{j=1}^nj=\frac{n-1}{2}=\Theta(n)$，最坏情况下，查找元素位置为最后一个位置$n=\Theta(n)$

---

2.3-2

```c++
std::vector<int> & merge_(std::vector<int> & a, int p, int q, int r){
    int n1 = q - p + 1;
    int n2 = r - q;
    std::vector<int> al(n1);
    std::vector<int> ar(n2);
    for(int i = 0; i < n1; ++i)
        al[i] = a[p + i];
    for(int j = 0; j < n2; ++j)
        ar[j] = a[q + 1 + j];
    int i = 0, j = 0, k = p;
    while(i < al.size() && j < ar.size()){
        a[k++] = (al[i] <= ar[j] ? al[i++] : ar[j++]);
    }
    while(i < al.size())
        a[k++] = al[i++];
    while(j < ar.size())
        a[k++] = ar[j++];
    return a;
}
```

2.3-3

设$n=2^{n'}$，当$n'=1$时，$T(2)=2\lg2=2$成立

当$n'=2$时，$T(4)=2T(2)+4=8=4\lg4$成立

假设当$n'=k$时，$T(2^k)=2T(2^{k-1})+2^k=k\cdot2^k$

则$n'=k+1$时，$T(2^{k+1})=2T(2^k)+2^{k+1}=(k+1)2^{k+1}$成立

因此原命题成立

2.3-4 $T(n)=c,n=1;\ T(n)=T(n-1)+n,n\ge1$

